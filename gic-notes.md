# GIC Notes (relevant for multikernel)

## GICv2

Specifically: "ARM IHI 0048B.b" ID072613.


p1-19:

>    This is an interrupt generated by software writing to a GICD_SGIR register in the GIC. The
>    system uses SGIs for interprocessor communication.
>    An SGI has edge-triggered properties. The software triggering of the interrupt is equivalent
>    to the edge transition of the interrupt request signal.
>    When an SGI occurs in a multiprocessor implementation, the CPUID field in the Interrupt
>    Acknowledge Register, GICC_IAR, or the Aliased Interrupt Acknowledge Register,
>    GICC_AIAR, identifies the processor that requested the interrupt.
>    In an implementation that includes the GIC Virtualization Extensions:
>
>     - when an SGI occurs, management registers in the GIC virtualization Extensions
>       enable the requesting processor to be reported to the Guest OS, as required by the
>       GIC specifications
>
>     - by writing to the management registers in the GIC Virtualization Extensions, a
>       hypervisor can generate a virtual interrupt that appears to a virtual machine as an SGI.
>       See Software-generated interrupts on page 5-165 and List Registers, GICH_LRn on
>       page 5-176 for more information.

p1-19 §1.4.3:

>    In a multiprocessor implementation, there are two models for handling interrupts:
>
>    **1-N model**
>        Only one processor handles this interrupt. The system must implement a mechanism to determine
>        which processor handles an interrupt that is programmed to target more than one processor.
>
>        - The ARM GIC architecture does not guarantee that a 1-N interrupt is presented to:
>            - all processors listed in the target processor list
>            - an enabled interface, where at least one interface is enabled.
>
>        - A 1-N interrupt might be presented to an interface where the processor has masked the
>          interrupt event, see Implications of the 1-N model on page 3-41.
>
>    **N-N model**
>        All processors receive the interrupt independently. When a processor acknowledges the interrupt,
>        the interrupt pending state is cleared only for that processor. The interrupt remains pending for the
>        other processors


p1-20:

>    **Interrupt banking**
>        In a multiprocessor implementation, for PPIs and SGIs, the GIC can have multiple interrupts with
>        the same interrupt ID. Such an interrupt is called a banked interrupt, and is identified uniquely by
>        the combination of its interrupt ID and its associated CPU interface. For more information see
>        Interrupt IDs on page 2-24.


p2-24:

>    Each connected processor issues an SGI by writing to the GICD_SGIR in the Distributor. Each write
>    can generate SGIs with the same ID that target multiple processors.
>    In the Distributor, an SGI is identified uniquely by the combination of its interrupt number, ID0-ID15,
>    the target processor ID, CPUID0-CPUID7, and the processor source ID, CPUID0-CPUID7, of the
>    processor that issued the SGI. When the CPU interface communicates the interrupt ID to a targeted
>    processor, it also provides the processor source ID, so that the targeted processor can uniquely identify
>    the SGI.
>    SGI banking means the GIC can handle multiple SGIs simultaneously, without resource conflicts.


p2-26:

>   The processor acknowledges the interrupt request by reading the CPU interface Interrupt Acknowledge Register.
>   ...
>   When the interrupt handler on the processor has completed the processing of an interrupt, it writes to the CPU
>   interface to indicate interrupt completion. There are two stages to interrupt completion:
>   In a GICv2 implementation, the GICC_CTLR.EOImode bit determines whether:
>       • the two stages happen together, when the processor writes to the CPU interface End of Interrupt register
>       • the two stages are separated, so that:
>           — priority drop happens when the processor writes to the CPU interface End of Interrupt register
>           — interrupt deactivation happens later, when the processor writes to the CPU interface Deactivate
>             Interrupt register.


p3-35:

>    Handling different interrupt types in a multiprocessor system
>    A GIC supports peripheral interrupts and software-generated interrupts, see Interrupt types on page 1-18.
>    In a multiprocessor implementation the GIC handles:
>    • software generated interrupts (SGIs) using the GIC N-N model
>    • peripheral (hardware) interrupts using the GIC 1-N model.
>    See Models for handling interrupts on page 1-19 for definitions of the two models.

p3-35/36:

>    GICD_ISENABLER0 provides the Set-enable bits for both:
>    • SGIs, using interrupt IDs 15-0, corresponding to register bits [15:0]
>    • PPIs, using interrupt IDs 31-16, corresponding to register bits [31:16].
>
>    The remaining GICD_ISENABLERns, from GICD_ISENABLER1, provide the Set-enable bits for the SPIs,
>    starting at interrupt ID 32.
>
>    If an interrupt is:
>    • not supported, the Set-enable bit corresponding to its interrupt ID is RAZ/WI
>    • supported and permanently enabled, the Set-enable bit corresponding to its interrupt ID is RAO/WI.
>
>    Software uses the GICD_ICENABLERns to discover the interrupts that are permanently enabled. For each
>    implemented GICD_ICENABLERn, starting with GICD_ICENABLER0, software:
>
>    1.Writes 0xFFFFFFFF to the GICD_ICENABLERn. This disables all interrupts that can be disabled.
>    2.Reads the value of the GICD_ICENABLERn. Bits that read as 1 correspond to interrupts that are
>    permanently enabled.
>    3.Writes 1 to any GICD_ISENABLERn bits corresponding to interrupts that must be re-enabled.



p3-38
> For PPIs and SGIs, the active status of particular interrupt ID is banked between CPU interfaces. This
> means that if a particular interrupt ID is active or active and pending on a CPU interface, then no
> interrupt with that same ID is signaled on that CPU interface.



p3-40:

>   Whether SGIs are permanently enabled, or can be enabled and disabled by writes to the GICD_ISENABLERn and
>   GICD_ICENABLERn, is IMPLEMENTATION DEFINED.


p3-40:

>    For SGIs, the GIC ignores writes to the corresponding GICD_ISPENDRn and GICD_ICPENDRn bits. A processor
>    cannot change the state of a software-generated interrupt by writing to these registers. Typically, an SGI is made
>    pending by writing to the GICD_SGIR. In GICv2, the pending state of SGIs can also be modified directly using the
>    GICD_SPENDSGIRn and GICD_CPENDSGIRn bits.


p3-40/41:

>    Generating an SGI
>    A processor generates an SGI by writing to an GICD_SGIR. An SGI can target multiple processors, and the
>    GICD_SGIR write specifies the target processor list. The GICD_SGIR includes optimization for:
>    •  interrupting only the processor that writes to the GICD_SGIR
>    •  interrupting all processors other than the one that writes to the GICD_SGIR.
>
>    SGIs from different processors use the same interrupt IDs. Therefore, any target processor can receive SGIs with
>    the same interrupt ID from different processors. However, the pending states of any two SGIs are independent if
>    any of the following are different:
>    •  interrupt ID
>    •  source processor
>
>    Only one interrupt with a specific interrupt ID can be active on a CPU interface at any time. This means that a CPU
>    interface cannot have two SGIs with the same interrupt ID active at the same time, even if different processors have
>    signaled SGIs with the same interrupt ID to that processor.
>
>    On the CPU interface of the target processor, reading the GICC_IAR for an SGI returns both the interrupt ID and
>    the CPU ID of the processor that generated the interrupt, the source processor for the interrupt. The combination of
>    interrupt ID and source CPU ID uniquely identifies the interrupt to the target processor.
>
>    In a multiprocessor implementation, the interrupt priority of each SGI interrupt ID is defined independently for each
>    target processor, see Interrupt Priority Registers, GICD_IPRIORITYRn on page 4-104. For each CPU interface, all
>    SGIs with a particular interrupt ID that are pending on that interface have the same priority and must be handled
>    serially. The order in which the CPU interface serializes these SGIs is IMPLEMENTATION SPECIFIC


p3-40:

>    In GICv1, more than one target processor might have obtained this interrupt ID, if the processors read their
>    GICC_IAR registers at very similar times. The system might require software on the target processors to
>    ensure that only one processor runs its interrupt service routine. A typical mechanism to achieve this is
>    implementing, in shared memory, a lock on the interrupt service routine (ISR).


p4-113:

> Figure 4-17 shows the GICD_SGIR bit assignments.
>
>    [25:24]TargetListFilter
>    Determines how the distributor must process the requested SGI:
>    0b00
>    Forward the interrupt to the CPU interfaces specified in the CPUTargetList field a.
>    0b01
>    Forward the interrupt to all CPU interfaces except that of the processor that requested the
>    interrupt.
>    0b10
>    Forward the interrupt only to the CPU interface of the processor that requested the
>    interrupt.
>    0b11
>    Reserved.
>
>    [23:16]CPUTargetList
>    When TargetList Filter = 0b00, defines the CPU interfaces to which the Distributor must forward the
>    interrupt.
>    Each bit of CPUTargetList[7:0] refers to the corresponding CPU interface, for example
>    CPUTargetList[0] corresponds to CPU interface 0. Setting a bit to 1 indicates that the interrupt must be
>    forwarded to the corresponding interface.
>    If this field is 0x00 when TargetListFilter is 0b00, the Distributor does not forward the interrupt to any
>    CPU interface.


also the SGI Clear-Pending/Set-Pending, not useful though.

## GICv3

> Software Generated Interrupts (SGIs)
> With the ability of GICv3 to support large-scale systems, the context of an SGI is modified and no
> longer includes the identity of the source PE. See Software Generated Interrupts on page 4-60.


p1-23:

>    Software Generated Interrupt (SGI)
>    SGIs are typically used for inter-processor communication, and are generated by a write to an SGI
>    register in the GIC:
>    •   SGIs can be Group 0 interrupts, Secure Group 1 interrupts, or Non-secure Group 1 interrupts.
>    •   SGIs have edge-triggered behavior.
>    •   SGIs are never routed using an ITS.
>    •   SGIs have an active state and therefore require explicit deactivation.
>


p1-24:

>    Models for handling interrupts
>    In a multiprocessor implementation, the following models exist for handling interrupts:
>
>    Targeted distribution model
>        This model applies to all PPIs and to all LPIs. It also applies to:
>        •SPIs during non-legacy operation, if GICD_IROUTER<n>.Interrupt_Routing_Mode == 0.
>        •During legacy operation, when GICD_CTLR.ARE_* == 0, if only one bit in the appropriate
>        GICD_ITARGETSR<n> field == 1.
>        A target PE that has been specified by software receives the interrupt.
>
>    Targeted list model
>        This model applies to SGIs only. Multiple PEs receive the interrupt independently. When a PE
>        acknowledges the interrupt, the interrupt pending state is cleared only for that PE. The interrupt
>        remains pending for each PE independently until it has been acknowledged by the PE.
>
>    1 of N model
>        This model applies to SPIs only. The interrupt is targeted at a specified set of PEs, and is taken on
>        only one PE in that set. The PE that takes the interrupt is selected in an IMPLEMENTATION DEFINED
>        manner. The architecture applies restrictions on which PEs can be selected, see Enabling the
>        distribution of interrupts on page 4-69.




>    Redistributors provide a programming interface for:
>    •   Identifying, controlling, and configuring supported features to enable interrupts and
>        interrupt routing of the implementation.
>    •   Enabling or disabling SGIs and PPIs.
>    •   Setting the priority level of SGIs and PPIs.
>    •   Setting each PPI to be level-sensitive or edge-triggered.
>    •   Assigning each SGI and PPI to an interrupt group.
>    •   Controlling the pending state of SGIs and PPIs.
>    •   Controlling the active state of SGIs and PPIs.
>    •   Power management support for the connected PE.
>    •   Where LPIs are supported, base address control for the data structures in memory that
>        support the associated interrupt properties and their pending status.
>    •   Where GICv4 is supported, base address control for the data structures in memory
>        that support the associated virtual interrupt properties and their pending status.
>        The Redistributor registers are identified by the GICR_ prefix.


>    PPIs, SGIs, and SPIs have an active state in the IRI and must be deactivated.
>    SGIs and PPIs must be deactivated by the PE that activated the interrupt. SPIs can be deactivated by a different PE.

>    Arm expects hardware implementations to report GICD_TYPER2.nASSGIcap==0, indicating that
>    GICD_CTLR.nASSGIreq is RES0





p2-39:

>    2.3.1
>    Routing SPIs and SGIs by PE affinity
>    SPIs are routed using an affinity address and the routing mode information that is held in GICD_IROUTER<n>.
>    SGIs are routed using the affinity address and routing mode information that is written by software when it generates
>    the SGI.
>    SGIs are generated using the following registers:
>    • ICC_SGI0R_EL1.
>    • ICC_SGI1R_EL1.
>    • ICC_ASGI1R_EL1.
>
>    Note
>    If GICD_TYPER.RSS is 0 or ICC_CTLR_ELx.RSS is 0, Arm strongly recommends that only values in the range
>    0-15 are used at affinity level 0 to align with the SGI target list capability. See Software Generated Interrupts on
>    page 4-60.
>
>    SPIs and SGIs are routed using different registers:
>    •  SPIs are routed using GICD_IROUTER<n>.Interrupt_Routing_Mode:
>       — If GICD_IROUTER<n>.Interrupt_Routing_Mode is cleared to 0, SPIs are routed to a single PE
>           specified by a.b.c.d.
>       —  If GICD_IROUTER<n>.Interrupt_Routing_Mode is set to 1, SPIs are routed to any PE defined as a
>           participating node:
>           - The mechanisms by which the IRI selects the target PE is IMPLEMENTATION DEFINED.
>           - When ICC_CTLR_EL3.PMHE == 1, or ICC_CTLR_EL1.PMHE == 1, the ICC_PMR_EL1 register
>               associated with the PE might be used by the IRI to determine the target PE.
>           For more information about participating nodes, see Participating nodes.
>
>    • SGIs are routed using ICC_SGI0R_EL1.IRM, and ICC_SGI1R_EL1.IRM:
>        — If the IRM bit is set to 1, SGIs are routed to all participating PEs in the system, excluding the
>           originating PE.
>        — If the IRM bit is cleared to 0, SGIs are routed to a group of PEs, specified by a.b.c.targetlist.
>             Targeting an unimplemented affinity has no effect.












p12-622
>    nASSGIcap, bit [8]
>    Indicates whether SGIs can be configured to not have an active state.
>    The value of this field is an IMPLEMENTATION DEFINED choice of:
>    0b0SGIs have an active state.
>    0b1SGIs can be globally configured not to have an active state.
>    This bit is RES0 on implementations that support two Security states.
>    Access to this field is RO.

>    Figure 4-3
>    Active: Not applicable for SGIs when GICD_CTLR.nASSGIreq==1, and for LPIs.


>    **4.4 Software Generated Interrupts**
>    SGIs are typically used for inter-processor communication, and are generated by a write to an SGI register in the
>    GIC. SGIs can be either Group 0 or Group 1 interrupts, and they can support only edge-triggered behavior.
>
>    The registers associated with the generation of SGIs are part of the CPU interface:
>    •   A PE generates a Group 1 SGI by writing to ICC_SGI1R_EL1 or ICC_ASGI1R_EL1.
>    •   A PE generates a Group 0 SGI by writing to ICC_SGI0R_EL1.
>    •   Routing information is supplied as the bit field value in the write to the register that generated the SGI. The
>        SGI can be routed to:
>        — The group of PEs specified by a.b.c.targetlist. This can include the originating PE.
>        — All participating PEs in the system, excluding the originating PE.
>        See Routing SPIs and SGIs by PE affinity on page 2-39 for more information.
>
>    ICC_SGI1R_EL1 allows software executing in a Secure state to generate Secure Group 1 SGIs.
>    ICC_SGI1R_EL1 allows software executing in a Non-secure state to generate Non-secure Group 1 SGIs.
>    ICC_ASGI1R_EL1 allows software executing in a Secure state to generate Non-secure Group 1 SGIs.
>    ICC_ASGI1R_EL1 allows software executing in a Non-secure state to generate Secure Group 1 SGIs, if permitted
>    by the settings of GICR_NSACR in the Redistributor corresponding to the target PE.
>    ICC_SGI0R_EL1 allows software executing in Secure state to generate Group 0 SGIs.
>    ICC_SGI0R_EL1 allows software executing in Non-secure state to generate Group 0 SGIs, if permitted by the
>    settings of GICR_NSACR in the Redistributor corresponding to the target PE.
>
>    For more information about the use of control registers to forward SGIs to a target PE, see Table 12-14 on
>    page 12-207.
>



p4-69:

>    **SGIs**
>    SGIs can be enabled and disabled by writing to GICR_ISENABLER0 and GICR_ICENABLER0
>    when affinity routing is enabled. Individual SGIs can also be enabled and disabled by writing to
>    GICD_ISENABLER<n> and GICD_ICENABLER<n>. n = 0 for SGIs, if legacy operation for
>    physical interrupts is supported and configured.
>
>    Note
>    Whether SGIs are permanently enabled, or can be enabled and disabled by writes to
>    GICR_ISENABLER0 and GICR_ICENABLER0, is IMPLEMENTATION DEFINED.


^^ same as GICv2.


diversion: GIC-500 manual, p3-7/8: (ITARGETSRn)

> The registers that contain the SGI and PPI interrupts are read-only and the value is the core number of the current access. It is encoded in
> an 8-bit one-hot field, for each implemented interrupt, and encoded as zero for interrupts that are not implemented. For more information on
> core target field bit values, see the ARM® Generic Interrupt Controller Architecture Specification, GIC architecture version 3.0 and version
> 4.0.



p12-193: registers are atomic

>    **GIC memory-mapped register access**
>    In any system, access to the following registers must be supported:
>    • Single copy atomic 32-bit accesses to:
>        — All 32-bit GICC_*, GICV_*, GICD_*, GICH_*, GITS_*, and GICR_* registers.
>    • Single copy atomic 64-bit accesses to:
>       — All 64-bit GITS_* registers.
>       — All 64-bit GICD_* registers.
>       — All 64-bit GICR_* registers.
>
>    The following accesses are not supported:
>    • Byte access to registers other than those specifically listed in this section.
>    • Unaligned word accesses. These accesses are not word single-copy atomic.
>    • Unaligned doubleword accesses. These accesses are not doubleword single-copy atomic.
>    • Word accesses for registers marked as requiring a 64-bit access.
>    • Doubleword accesses, other than those specifically listed in this section.
>    • Quadword or higher.
>    • Exclusive accesses.



Refer: Table 12-14 Forwarding an SGI to a target PE

ignore as secure grup 1 etc.


p12-234 in ICC_CTLR_EL1

>    RSS, bit [18]
>        Range Selector Support. Possible values are:
>        0b0 Targeted SGIs with affinity level 0 values of 0 - 15 are supported.
>        0b1 Targeted SGIs with affinity level 0 values of 0 - 255 are supported.
>        This bit is read-only.


p12-276 12.2.22 ICC_SGI1R_EL1, Interrupt Controller Software Generated Interrupt Group 1 Register


>    Aff3: 55-48, AFf3 of cluster for which SGI generated (if IRM==0)
>
>    RS/RangeSelector[47:44]: Controls which group of 16 values is represented by the TargetList field.
>                        TargetList[n] represents aff0 value ((RS * 16) + n).
>                        possibly reserved
>                   (affinity routing only)
>    IRM[40]:
>        0b0  Interrupts routed to the PEs specified by Aff3.Aff2.Aff1.<target list>.
>        0b1  Interrupts routed to all PEs in the system, excluding “self”.
>
>    Aff2: affinity 2 (if IRM==0)
>
>    INTID[27:24] of SGI
>
>    Aff1: affinity 1 (if IRM==0)
>
>    TargetList, bits [15:0]
>        Target List. The set of PEs for which SGI interrupts will be generated. Each bit corresponds to the
>        PE within a cluster with an Affinity 0 value equal to the bit number.
>      -> paired with RS...


p12-711:
>    GICR_TYPER,
>        *Affinity_Value, bits [63:32]*
>        The identity of the PE associated with this Redistributor.
>        Bits [63:56] provide Aff3, the Affinity level 3 value for the Redistributor.
>        Bits [55:48] provide Aff2, the Affinity level 2 value for the Redistributor.
>        Bits [47:40] provide Aff1, the Affinity level 1 value for the Redistributor.
>        Bits [39:32] provide Aff0, the Affinity level 0 value for the Redistributor.
>        This field has an IMPLEMENTATION DEFINED value.
>        Access to this field is RO.
>
> _
>       *Processor_Number, bits [23:8]*
>       A unique identifier for the PE. When GITS_TYPER.PTA == 0, an ITS uses this field to identify the
>       interrupt target.
>       When affinity routing is disabled for a Security state, this field indicates which
>       GICD_ITARGETSR<n> corresponds to this Redistributor.
>       This field has an IMPLEMENTATION DEFINED value.
>       Access to this field is RO.

**NOTE:?**
These combined imply that there is 16 different possible targets?
    "Affinity 0 value equal to the bit number <=> PE within a cluster"



§12.9 interesting?
> **GICD_ICACTIVER<n>**, **GICD_ICENABLER<n>**, **GICD_ICFGR**
> GICD_ICACTIVER0 is Banked for each connected PE with GICR_TYPER.Processor_Number < 8
> Accessing GICD_ICACTIVER0 from a PE with GICR_TYPER.Processor_Number > 7 is
> CONSTRAINED UNPREDICTABLE:
> •Register is RAZ/WI.
> •An UNKNOWN banked copy of the register is accessed.
> The number of implemented GICD_ICENABLER<n> registers is (GICD_TYPER.ITLinesNumber+1). Registers are numbered from 0.


p12-558:

> **GICD_ICFGR**
> For SGIs and PPIs:
>   • When ARE is 1 for the Security state of an interrupt, the field for that interrupt is RES0 and
>     an implementation is permitted to make the field RAZ/WI in this case.
>   • Equivalent functionality is provided by GICR_ICFGR<n>
> For SGIs, Int_config fields are RO, meaning that GICD_ICFGR0 is RO.
> Changing Int_config when the interrupt is individually enabled is UNPREDICTABL


p12-584: how targets (Routing) works in v3 with affinity routing

> **GICD_IROUTER<n>, Interrupt Routing Registers, n = 32 - 1019**
>    Interrupt_Routing_Mode, bit [31]
>    Interrupt Routing Mode. Defines how SPIs are routed in an affinity hierarchy:
>    0b0Interrupts routed to the PE specified by a.b.c.d. In this routing, a, b, c, and d are the
>    values of fields Aff3, Aff2, Aff1, and Aff0 respectively.

without affinity routing, we use ITARGETR

>   GICD_ITARGETSR<n>, Interrupt Processor Targets Registers, n = 0 - 254
>   The GICD_ITARGETSR<n> characteristics are:
>   Purpose
>   When affinity routing is not enabled, holds the list of target PEs for the interrupt. That is, it holds
>   the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and has
>   sufficient priority.
>        GICD_ITARGETSR0 to GICD_ITARGETSR7 are Banked for each connected PEwith
>        GICR_TYPER.Processor_Number < 8.
>        Accessing GICD_ITARGETSR0 to GICD_ITARGETSR7 from a PE with
>        GICR_TYPER.Processor_Number > 7 is CONSTRAINED UNPREDICTABLE:
>        •Register is RAZ/WI.
>        •An UNKNOWN banked copy of the register is accessed.


xxx: GICD_SGIR used when no affinity routing, different meaning.
